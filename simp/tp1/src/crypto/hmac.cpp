#include "hmac.hpp"

#include <cstdio>

const uint8_t HMAC::ipad = 0x36;
const uint8_t HMAC::opad = 0x5c;

myerror_t HMAC::test()
{
  myerror_t err = ERROR_UNEXPECTED;
  size_t byte_idx;
  uint8_t result[32];

  HMAC temp;
  size_t hashSize = temp.hashFunction->hashSize;

  for ( unsigned test_idx = 0 ; test_idx < 2 ; test_idx++ )
    {
      temp.init(TV_keys[test_idx],TV_klengths[test_idx]);
      temp.update(TV_messages[test_idx],TV_mlengths[test_idx]);
      temp.final(result);
      for ( byte_idx = 0 ; (byte_idx < hashSize) && (result[byte_idx] == TV_tags[test_idx][byte_idx]) ; byte_idx ++ )
	;
      if ( byte_idx != hashSize )
	goto end;
    }
  
  if ( byte_idx == hashSize )
    err = NO_ERROR;
  
 end:
  return err;
}

void HMAC::init(const uint8_t *key, size_t length)
{
  unsigned i;
  uint8_t byte;
  
  hashFunction = new SHA256();
  hashFunction->init();

  keyLength = length;
  keyValue = key;

  for ( i = 0 ; i < length ; i ++ )
    {
      byte = key[i] ^ ipad;
      hashFunction->update(&byte,1);
    }
  for ( ; i < hashFunction->blockSize ; i++ )
    {
      hashFunction->update(&ipad,1);
    }

  
}

void HMAC::update(const uint8_t *data, size_t length)
{
  hashFunction->update(data,length);
}

void HMAC::final(uint8_t *tag)
{
  unsigned i;
  uint8_t byte, hash[32];

  hashFunction->final(hash);
  
  hashFunction->init();
  
  for ( i = 0 ; i < keyLength ; i ++ )
    {
      byte = keyValue[i] ^ opad;
      hashFunction->update(&byte,1);
    }
  for ( ; i < hashFunction->blockSize ; i++ )
    {
      hashFunction->update(&opad,1);
    }   
  hashFunction->update(hash,32);
  hashFunction->final(tag);
}

/* DATA */

const size_t HMAC::TV_klengths[3] = {
  20, 4, 131
};

const uint8_t HMAC::TV_keys[3][256] = {
  {0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b},
  "Jefe",
  {0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa}
};

const size_t HMAC::TV_mlengths[3] = {
  8, 28, 56
};

const uint8_t HMAC::TV_messages[3][128] = {
  "Hi There",
  "what do ya want for nothing?",
  "Test Using Larger Than Block-Size Key - Hash Key First"
   };

const uint8_t HMAC::TV_tags[3][32] = {
  {0xb0,0x34,0x4c,0x61,0xd8,0xdb,0x38,0x53,0x5c,0xa8,0xaf,0xce,0xaf,0x0b,0xf1,0x2b,0x88,0x1d,0xc2,0x00,0xc9,0x83,0x3d,0xa7,0x26,0xe9,0x37,0x6c,0x2e,0x32,0xcf,0xf7},
  {0x5b,0xdc,0xc1,0x46,0xbf,0x60,0x75,0x4e,0x6a,0x04,0x24,0x26,0x08,0x95,0x75,0xc7,0x5a,0x00,0x3f,0x08,0x9d,0x27,0x39,0x83,0x9d,0xec,0x58,0xb9,0x64,0xec,0x38,0x43}
};
